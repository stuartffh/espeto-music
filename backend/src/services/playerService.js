/**
 * Player Service - Controle centralizado do player com backup em banco de dados
 *
 * Features:
 * - Estado global sincronizado com banco de dados
 * - Recupera√ß√£o autom√°tica ap√≥s crash
 * - Auto-corre√ß√£o de inconsist√™ncias
 * - Backup cont√≠nuo do tempo de reprodu√ß√£o
 */

const prisma = require('../config/database');
const historicoService = require('./historicoService');

// Estado em mem√≥ria separado por loca√ß√£o (r√°pido para leitura)
// Chave: locacaoId ou 'global' para sistema global
let estadosMemoria = {
  global: {
    musicaAtual: null,
    status: 'stopped', // 'playing', 'paused', 'stopped'
    tempoAtual: 0,
    volume: 80,
    ultimaAtualizacao: Date.now(),
  }
};

// Helper para obter estado de uma loca√ß√£o espec√≠fica
function getEstadoMemoria(locacaoId = null) {
  const key = locacaoId || 'global';
  if (!estadosMemoria[key]) {
    estadosMemoria[key] = {
      musicaAtual: null,
      status: 'stopped',
      tempoAtual: 0,
      volume: 80,
      ultimaAtualizacao: Date.now(),
    };
  }
  return estadosMemoria[key];
}

let intervalSync = null;
let intervalBackup = null;
let intervalAutoplay = null;
let io = null;
let historicoAtualId = null; // ID do registro de hist√≥rico da m√∫sica atual

/**
 * Inicializa o player service e recupera estado do banco
 */
async function inicializar(socketIo) {
  io = socketIo;

  console.log('üéÆ Player Service: Inicializando...');

  // Recuperar estado do banco de dados
  await recuperarEstado();

  // Iniciar verificador de autoplay
  iniciarVerificadorAutoplay();

  console.log('‚úÖ Player Service inicializado');
}

/**
 * Recupera o estado salvo no banco ap√≥s crash/rein√≠cio
 */
async function recuperarEstado() {
  try {
    console.log('üîÑ Recuperando estado do player do banco de dados...');

    // Buscar estado salvo
    let estadoSalvo = await prisma.estado_player.findUnique({
      where: { id: 'singleton' }
    });

    // Se n√£o existe, criar registro inicial
    if (!estadoSalvo) {
      console.log('üìù Criando registro inicial de estado...');
      estadoSalvo = await prisma.estado_player.create({
        data: {
          id: 'singleton',
          status: 'stopped',
          tempoAtual: 0,
          volume: 80
        }
      });
    }

    // Se tinha m√∫sica tocando, recuperar
    if (estadoSalvo.musicaAtualId) {
      const musicaAtual = await prisma.pedidos_musica.findUnique({
        where: { id: estadoSalvo.musicaAtualId }
      });

      if (musicaAtual && musicaAtual.status === 'tocando') {
        console.log('üéµ Recuperando m√∫sica:', musicaAtual.musicaTitulo);
        console.log('‚è±Ô∏è  Tempo salvo:', Math.floor(estadoSalvo.tempoAtual), 'segundos');

        const estadoGlobal = getEstadoMemoria('global');
        estadoGlobal.musicaAtual = musicaAtual;
        estadoGlobal.status = estadoSalvo.status;
        estadoGlobal.tempoAtual = estadoSalvo.tempoAtual;
        estadoGlobal.volume = estadoSalvo.volume;
        estadoGlobal.ultimaAtualizacao = Date.now();

        // Se estava tocando, retomar
        if (estadoSalvo.status === 'playing') {
          console.log('‚ñ∂Ô∏è Retomando reprodu√ß√£o automaticamente...');
          iniciarSincronizacao();
          iniciarBackup();

          // Emitir evento para TVs retomarem
          if (io) {
            io.emit('player:iniciar', {
              musica: musicaAtual,
              estado: estadoGlobal,
            });
          }
        }
      } else {
        console.log('‚ö†Ô∏è  M√∫sica salva n√£o encontrada ou inconsistente, limpando estado...');
        await limparEstado();
      }
    } else {
      console.log('‚ÑπÔ∏è  Nenhuma m√∫sica em reprodu√ß√£o');
      const estadoGlobal = getEstadoMemoria('global');
      estadoGlobal.volume = estadoSalvo.volume;
    }

  } catch (error) {
    console.error('‚ùå Erro ao recuperar estado:', error);
  }
}

/**
 * Salva o estado atual no banco de dados
 */
async function salvarEstado(locacaoId = null) {
  try {
    // Por enquanto, salvar apenas o estado global no banco
    // TODO: Implementar salvamento separado por loca√ß√£o se necess√°rio
    if (locacaoId && locacaoId !== 'global') {
      console.log(`‚ÑπÔ∏è [SALVAR] Estado de loca√ß√£o ${locacaoId} n√£o salvo no banco (apenas em mem√≥ria)`);
      return;
    }

    const estadoGlobal = getEstadoMemoria('global');
    await prisma.estado_player.upsert({
      where: { id: 'singleton' },
      update: {
        musicaAtualId: estadoGlobal.musicaAtual?.id || null,
        status: estadoGlobal.status,
        tempoAtual: estadoGlobal.tempoAtual,
        volume: estadoGlobal.volume,
        ultimaAtualizacao: new Date(),
      },
      create: {
        id: 'singleton',
        musicaAtualId: estadoGlobal.musicaAtual?.id || null,
        status: estadoGlobal.status,
        tempoAtual: estadoGlobal.tempoAtual,
        volume: estadoGlobal.volume,
        atualizadoEm: new Date()
      }
    });
  } catch (error) {
    console.error('‚ùå Erro ao salvar estado:', error);
  }
}

/**
 * Limpa o estado do banco
 */
async function limparEstado() {
  await prisma.estado_player.update({
    where: { id: 'singleton' },
    data: {
      musicaAtualId: null,
      status: 'stopped',
      tempoAtual: 0,
    }
  });
  estadoMemoria.musicaAtual = null;
  estadoMemoria.status = 'stopped';
  estadoMemoria.tempoAtual = 0;
}

/**
 * Inicia backup peri√≥dico do estado (a cada 3 segundos)
 */
function iniciarBackup() {
  pararBackup();
  intervalBackup = setInterval(async () => {
    await salvarEstado();
  }, 3000); // Backup a cada 3 segundos
}

/**
 * Para backup peri√≥dico
 */
function pararBackup() {
  if (intervalBackup) {
    clearInterval(intervalBackup);
    intervalBackup = null;
  }
}

/**
 * Inicia uma nova m√∫sica
 * @param {Object} musica - Dados da m√∫sica
 * @param {string|null} locacaoId - ID da loca√ß√£o (null = global)
 */
async function iniciarMusica(musica, locacaoId = null) {
  console.log('‚ñ∂Ô∏è Player: Iniciando m√∫sica', musica.musicaTitulo);
  console.log(`   - Loca√ß√£o: ${locacaoId || 'global'}`);

  const estado = getEstadoMemoria(locacaoId);
  estado.musicaAtual = musica;
  estado.status = 'playing';
  estado.tempoAtual = 0;
  estado.ultimaAtualizacao = Date.now();

  // Salvar no banco imediatamente
  await salvarEstado(locacaoId);

  // Registrar no hist√≥rico
  try {
    const historico = await historicoService.registrarInicioMusica({
      pedidoId: musica.id,
      titulo: musica.musicaTitulo,
      youtubeId: musica.musicaYoutubeId,
      thumbnail: musica.musicaThumbnail,
      duracao: musica.musicaDuracao,
      nomeCliente: musica.nomeCliente,
      valor: musica.valor || 0,
      tipo: 'cliente'
    });
    historicoAtualId = historico.id;
  } catch (error) {
    console.error('‚ùå Erro ao registrar m√∫sica no hist√≥rico:', error);
  }

  // Iniciar sincroniza√ß√£o e backup
  iniciarSincronizacao();
  iniciarBackup();

  // Emitir evento WebSocket
  console.log('üîå [PLAYER] Verificando io para emitir player:iniciar...');
  console.log('üîå [PLAYER] io dispon√≠vel?', !!io);
  if (io) {
    console.log('üì° [PLAYER] Emitindo player:iniciar para:', musica.musicaTitulo);
    io.emit('player:iniciar', {
      musica,
      estado: estado,
    });
    console.log('‚úÖ [PLAYER] Evento player:iniciar emitido com sucesso');
  } else {
    console.error('‚ùå [PLAYER] IO n√£o dispon√≠vel! Evento player:iniciar N√ÉO foi emitido!');
  }

  return estado;
}

/**
 * Pausa a m√∫sica
 */
async function pausar(locacaoId = null) {
  const estado = getEstadoMemoria(locacaoId);
  
  if (estado.status === 'playing') {
    console.log('‚è∏Ô∏è Player: Pausando');
    console.log(`   - Loca√ß√£o: ${locacaoId || 'global'}`);
    estado.status = 'paused';
    estado.ultimaAtualizacao = Date.now();

    await salvarEstado(locacaoId);
    pararSincronizacao();
    // Manter backup para salvar estado pausado

    if (io) {
      io.emit('player:pausar', { estado: estado });
    }
  }
  return estado;
}

/**
 * Retoma a m√∫sica pausada
 */
async function retomar(locacaoId = null) {
  const estado = getEstadoMemoria(locacaoId);
  
  if (estado.status === 'paused') {
    console.log('‚ñ∂Ô∏è Player: Retomando');
    console.log(`   - Loca√ß√£o: ${locacaoId || 'global'}`);
    estado.status = 'playing';
    estado.ultimaAtualizacao = Date.now();

    await salvarEstado(locacaoId);
    iniciarSincronizacao();

    if (io) {
      io.emit('player:retomar', { estado: estado });
    }
  }
  return estado;
}

/**
 * Para completamente
 */
async function parar(locacaoId = null) {
  console.log('‚èπÔ∏è Player: Parando');
  console.log(`   - Loca√ß√£o: ${locacaoId || 'global'}`);

  const estado = getEstadoMemoria(locacaoId);

  // Registrar fim da m√∫sica no hist√≥rico
  if (historicoAtualId) {
    try {
      await historicoService.registrarFimMusica(historicoAtualId, Math.floor(estado.tempoAtual));
      historicoAtualId = null;
    } catch (error) {
      console.error('‚ùå Erro ao registrar fim da m√∫sica no hist√≥rico:', error);
    }
  }

  pararSincronizacao();
  pararBackup();

  estado.musicaAtual = null;
  estado.status = 'stopped';
  estado.tempoAtual = 0;
  estado.ultimaAtualizacao = Date.now();

  await salvarEstado(locacaoId);

  if (io) {
    io.emit('player:parar', { estado: estado });
  }

  return estado;
}

/**
 * Pula para a pr√≥xima m√∫sica
 */
async function pularMusica(locacaoId = null) {
  console.log('‚è≠Ô∏è Player: Pulando m√∫sica');
  console.log(`   - Loca√ß√£o: ${locacaoId || 'global'}`);

  const musicaService = require('./musicaService');
  const estado = getEstadoMemoria(locacaoId);

  if (estado.musicaAtual) {
    const proximaMusica = await musicaService.pularMusica(estado.musicaAtual.id);

    pararSincronizacao();
    pararBackup();

    if (proximaMusica) {
      return await iniciarMusica(proximaMusica, locacaoId);
    } else {
      return await parar(locacaoId);
    }
  }

  return estado;
}

/**
 * Chamado quando a m√∫sica termina naturalmente
 * @param {string|null} locacaoId - ID da loca√ß√£o (null = global)
 */
async function musicaTerminou(locacaoId = null) {
  console.log('üéµ Player: M√∫sica terminou');
  console.log(`   - Loca√ß√£o: ${locacaoId || 'global'}`);

  const musicaService = require('./musicaService');
  const estado = getEstadoMemoria(locacaoId);

  if (estado.musicaAtual) {
    const proximaMusica = await musicaService.concluirMusica(estado.musicaAtual.id, locacaoId);

    pararSincronizacao();
    pararBackup();

    if (proximaMusica) {
      return await iniciarMusica(proximaMusica, locacaoId);
    } else {
      return await parar(locacaoId);
    }
  }

  return estado;
}

/**
 * Ajusta o volume
 */
async function ajustarVolume(nivel, locacaoId = null) {
  console.log('üîä Player: Volume ajustado para', nivel);
  console.log(`   - Loca√ß√£o: ${locacaoId || 'global'}`);
  
  const estado = getEstadoMemoria(locacaoId);
  estado.volume = nivel;

  await salvarEstado(locacaoId);

  if (io) {
    io.emit('player:volume', { volume: nivel });
  }

  return estado;
}

/**
 * Busca para um tempo espec√≠fico
 */
async function buscarTempo(tempo, locacaoId = null) {
  console.log('‚è© Player: Buscando para', tempo, 'segundos');
  console.log(`   - Loca√ß√£o: ${locacaoId || 'global'}`);
  
  const estado = getEstadoMemoria(locacaoId);
  estado.tempoAtual = tempo;
  estado.ultimaAtualizacao = Date.now();

  await salvarEstado(locacaoId);

  if (io) {
    io.emit('player:buscar', { tempo });
  }

  return estado;
}

/**
 * Retorna o estado atual
 */
function obterEstado(locacaoId = null) {
  const estado = getEstadoMemoria(locacaoId);
  return { ...estado };
}

/**
 * Sincroniza√ß√£o de tempo (a cada segundo)
 */
function iniciarSincronizacao() {
  pararSincronizacao();

  intervalSync = setInterval(() => {
    if (estadoMemoria.status === 'playing') {
      const agora = Date.now();
      const deltaSegundos = (agora - estadoMemoria.ultimaAtualizacao) / 1000;
      estadoMemoria.tempoAtual += deltaSegundos;
      estadoMemoria.ultimaAtualizacao = agora;

      // Emitir sync a cada 5 segundos
      if (Math.floor(estadoMemoria.tempoAtual) % 5 === 0) {
        if (io) {
          io.emit('player:sync', {
            tempo: estadoMemoria.tempoAtual,
            status: estadoMemoria.status,
          });
        }
      }
    }
  }, 1000);
}

/**
 * Para sincroniza√ß√£o
 */
function pararSincronizacao() {
  if (intervalSync) {
    clearInterval(intervalSync);
    intervalSync = null;
  }
}

/**
 * Inicia verificador peri√≥dico de autoplay
 * Verifica a cada 10 segundos se h√° m√∫sicas na fila e player parado
 */
function iniciarVerificadorAutoplay() {
  pararVerificadorAutoplay();

  console.log('üîÑ Iniciando verificador de autoplay (a cada 10 segundos)');

  intervalAutoplay = setInterval(async () => {
    try {
      // üéØ Usar fun√ß√£o centralizada de autoplay
      await garantirAutoplay();
    } catch (error) {
      console.error('‚ùå Erro no verificador de autoplay:', error);
    }
  }, 10000); // A cada 10 segundos
}

/**
 * Para verificador de autoplay
 */
function pararVerificadorAutoplay() {
  if (intervalAutoplay) {
    clearInterval(intervalAutoplay);
    intervalAutoplay = null;
  }
}

/**
 * üéØ GARANTIR AUTOPLAY - Fun√ß√£o centralizada e robusta
 *
 * Esta fun√ß√£o SEMPRE garante que uma m√∫sica seja iniciada se:
 * 1. N√£o h√° m√∫sica tocando atualmente
 * 2. Existe m√∫sica "pago" aguardando na fila
 *
 * Deve ser chamada em TODOS os pontos onde m√∫sicas podem entrar na fila:
 * - Ap√≥s criar pedido em modo gratuito
 * - Ap√≥s webhook aprovar pagamento
 * - Ap√≥s socket receber evento de pagamento
 * - No verificador peri√≥dico
 *
 * @param {string|null} locacaoId - ID da loca√ß√£o (null = global)
 * @returns {Promise<Object|null>} M√∫sica iniciada ou null
 */
async function garantirAutoplay(locacaoId = null) {
  try {
    console.log('\nüéØ ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    console.log('   GARANTIR AUTOPLAY - Verifica√ß√£o Iniciada');
    console.log('   ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

    // 1. Verificar estado atual do player em mem√≥ria
    console.log('1Ô∏è‚É£ Verificando estado do player em mem√≥ria...');
    console.log(`   - Status: ${estadoMemoria.status}`);
    console.log(`   - M√∫sica atual: ${estadoMemoria.musicaAtual?.musicaTitulo || 'Nenhuma'}`);
    console.log(`   - ID: ${estadoMemoria.musicaAtual?.id || 'N/A'}`);

    if (estadoMemoria.musicaAtual && estadoMemoria.status === 'playing') {
      console.log('‚úÖ J√° existe m√∫sica tocando, n√£o precisa iniciar nova');
      console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');
      return null;
    }

    // 2. Verificar no banco se h√° m√∫sica com status "tocando"
    console.log('\n2Ô∏è‚É£ Verificando m√∫sica "tocando" no banco de dados...');
    console.log(`   - Loca√ß√£o: ${locacaoId || 'global'}`);
    const musicaService = require('./musicaService');
    const musicaTocandoBanco = await musicaService.buscarMusicaAtual(locacaoId);

    if (musicaTocandoBanco) {
      console.log(`‚ö†Ô∏è  INCONSIST√äNCIA DETECTADA: M√∫sica no banco como "tocando" mas player parado`);
      console.log(`   - M√∫sica: ${musicaTocandoBanco.musicaTitulo}`);
      console.log(`   - ID: ${musicaTocandoBanco.id}`);
      console.log(`   - A√ß√£o: Iniciando esta m√∫sica no player...`);

      await iniciarMusica(musicaTocandoBanco, locacaoId);
      console.log('‚úÖ M√∫sica inconsistente iniciada com sucesso');
      console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');
      return musicaTocandoBanco;
    }

    // 3. Buscar primeira m√∫sica paga na fila
    console.log('\n3Ô∏è‚É£ Buscando primeira m√∫sica "pago" na fila...');
    console.log(`   - Loca√ß√£o: ${locacaoId || 'global'}`);
    const proximaMusica = await musicaService.iniciarProximaMusicaSeNecessario(locacaoId);

    if (proximaMusica) {
      console.log(`üéµ M√∫sica encontrada e marcada como "tocando":`);
      console.log(`   - T√≠tulo: ${proximaMusica.musicaTitulo}`);
      console.log(`   - ID: ${proximaMusica.id}`);
      console.log(`   - Cliente: ${proximaMusica.nomeCliente || 'An√¥nimo'}`);
      console.log(`   - A√ß√£o: Iniciando no player...`);

      console.log('üéµ [AUTOPLAY] Chamando iniciarMusica...');
      await iniciarMusica(proximaMusica, locacaoId);
      console.log('‚úÖ [AUTOPLAY] AUTOPLAY BEM-SUCEDIDO! M√∫sica iniciada com sucesso');
      console.log('‚úÖ [AUTOPLAY] Verificar se evento player:iniciar foi emitido acima ‚¨ÜÔ∏è');
      console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');
      return proximaMusica;
    }

    // 4. Nenhuma m√∫sica para tocar
    console.log('\n‚ÑπÔ∏è  Nenhuma m√∫sica aguardando na fila');
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');
    return null;

  } catch (error) {
    console.error('\n‚ùå ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    console.error('   ERRO AO GARANTIR AUTOPLAY');
    console.error('   ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    console.error('Tipo:', error.constructor.name);
    console.error('Mensagem:', error.message);
    console.error('Stack:', error.stack);
    console.error('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');
    return null;
  }
}

/**
 * Atualiza o tempo atual do player (recebido do frontend via WebSocket)
 */
function atualizarTempoAtual(tempo) {
  if (estadoMemoria.musicaAtual && (estadoMemoria.status === 'playing' || estadoMemoria.status === 'paused')) {
    estadoMemoria.tempoAtual = tempo;
    estadoMemoria.ultimaAtualizacao = Date.now();
  }
}

module.exports = {
  inicializar,
  iniciarMusica,
  pausar,
  retomar,
  parar,
  pularMusica,
  ajustarVolume,
  buscarTempo,
  obterEstado,
  musicaTerminou,
  garantirAutoplay, // ‚≠ê NOVA FUN√á√ÉO EXPORTADA
  atualizarTempoAtual, // ‚≠ê FUN√á√ÉO DE SYNC DE TEMPO
};
